RWTexture2D<float4> State1;
RWTexture2D<float4> State2;
Texture2D<float4> State1Read;
Texture2D<float4> State2Read;
SamplerState samplerState1;
SamplerState samplerState2;
float4 CellColour;
float4 DeadColour;
float4 TextureSize;

int LiveNeighbors(Texture2D<float4> OldState,SamplerState sampler, uint3 position)
{
    int liveneighbors=0;
    for(int i=position.x-1;i<=position.x+1;i++)
    {
        for(int j=position.y-1;j<=position.y+1;j++)
        {
            if(!(i==position.x && j==position.y))
            {
                int x = i;
                int y = j;
                if(i<0)
                {x=TextureSize.x-1;}
                if(j<0)
                {y=TextureSize.y-1;}
                
                if(i>TextureSize.x-1)
                { x=0; }
                if(j>TextureSize.y-1)
                { y=0; }
                float2 check = {x,y};
                if( OldState.Sample(sampler,check)== CellColour)
                {
                    liveneighbors++;
                } 
            }
        }
    }
    return  liveneighbors;
}

float4 CellSim(RWTexture2D<float4> NewState,Texture2D<float4> OldState,SamplerState sampler,uint3 position)
{
    // we do the entire state update, then the correct kernel just reads the result- but the voids function like for loops
    // so we have to have this happen first and only once somehow
    // basically the entire (for x, for y part has happened already ny the time we're touching this
    // but my implementation had 3 different for loops, in this we would have to do them in one...
    // if we skip assigning update since that's controlled by kernel......
    int liveNeighbors = LiveNeighbors(OldState,sampler,position);
    if (liveNeighbors < 2 && OldState[position.x+position.y]== CellColour)
        NewState[position.xy]; 
    else if (liveNeighbors > 3 && OldState[position.x+position.y] == CellColour)
        NewState[position.xy];
    else if (liveNeighbors == 3 && OldState[position.x+position.y] != CellColour)
        NewState[position.xy] = CellColour; 
    else
    {
        //NewState[position.xy] = OldState[position.x+position.y];
    }
    return NewState[position.xy];
}

#pragma kernel InitFullTexture
[numthreads(8, 8, 1)]
void InitFullTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x % 7 == 0 || id.y % 3 == 0)
        State1[id.xy] = CellColour;
    State1[id.xy];
}

#pragma kernel InitRPentomino
[numthreads(8, 8, 1)]
void InitRPentomino(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 256 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 255 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 256 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 257 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 256 && id.y == 257)
        State1[id.xy] = CellColour;
}

#pragma kernel InitAcorn
[numthreads(8, 8, 1)]
void InitAcorn(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 256 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 257 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 254 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 258 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 259 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 254 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 253 && id.y == 257)
        State1[id.xy] = CellColour;
}

#pragma kernel InitGun
[numthreads(8, 8, 1)]
void InitGun(uint3 id : SV_DispatchThreadID)
{
    if (id.x == 256 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 255 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 254 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 255 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 255 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 254 && id.y == 258)
        State1[id.xy] = CellColour;
    if (id.x == 253 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 252 && id.y == 259)
        State1[id.xy] = CellColour;
    if (id.x == 252 && id.y == 253)
        State1[id.xy] = CellColour;
    if (id.x == 251 && id.y == 259)
        State1[id.xy] = CellColour;
    if (id.x == 251 && id.y == 253)
        State1[id.xy] = CellColour;
    if (id.x == 250 && id.y == 258)
        State1[id.xy] = CellColour;
    if (id.x == 250 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 249 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 249 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 249 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 240 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 240 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 239 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 239 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 259 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 259 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 259 && id.y == 253)
        State1[id.xy] = CellColour;
    if (id.x == 260 && id.y == 255)
        State1[id.xy] = CellColour;
    if (id.x == 260 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 260 && id.y == 253)
        State1[id.xy] = CellColour;
    if (id.x == 261 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 261 && id.y == 252)
        State1[id.xy] = CellColour;
    if (id.x == 263 && id.y == 257)
        State1[id.xy] = CellColour;
    if (id.x == 263 && id.y == 256)
        State1[id.xy] = CellColour;
    if (id.x == 263 && id.y == 252)
        State1[id.xy] = CellColour;
    if (id.x == 263 && id.y == 251)
        State1[id.xy] = CellColour;
    if (id.x == 273 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 273 && id.y == 253)
        State1[id.xy] = CellColour;
    if (id.x == 274 && id.y == 254)
        State1[id.xy] = CellColour;
    if (id.x == 274 && id.y == 253)
        State1[id.xy] = CellColour;
}

#pragma kernel Update1
[numthreads(8, 8, 1)]
void Update1(uint3 id : SV_DispatchThreadID)
{
    CellSim(State1,State2Read,samplerState2,id);
    State1[id.xy];
}

#pragma kernel Update2
[numthreads(8, 8, 1)]
void Update2(uint3 id : SV_DispatchThreadID)
{
    CellSim(State2,State1Read,samplerState1,id);
    State2[id.xy];
}


